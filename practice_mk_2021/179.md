结果：
Accepted
- 229/229 cases passed (12 ms)
- Your runtime beats 41.94 % of cpp submissions
- Your memory usage beats 84.46 % of cpp submissions (11.1 MB)

遇到的问题：
- int转string，百度后采用to_string方式
- vector的sort用法，记得是可以自己写排序规则函数，但具体实现忘了 p.s.一开始写在类里报错，需要static或写在全局
- 0搞的很烦，其实有几种情况：一个0 -> 0，多个0 -> 不要重复的0, 0前面有其他数字 -> 保留所有0
    根本原因是0在首位不写，所以判断首位是否有有效数字即可；如果一直没有有效数字，就全删掉再补个0
- 对于[3,33]的问题，产生了递归无法跳出的error；原因是只考虑了[3,3]。所以加两个flag判断已经读完一遍了。

思路：
- 先试了几组数找一下规律，发现：
    - 数字越大越优先，9>8..
    - 首位数字相同需要比较，89>8>809..
- 初步想法：将所有数字补充到一样的位数，然后直接排序：
    - 如89=898，8=888，809=809...但是存在问题
    - 89>898，这个怎么判断想了比较久
- 进一步想法：指针指向head，一起移动，到尾端之后再回去（链表提供灵感）
    - 89 （8989...）
    - 898（8988...）
    - 第四次查找就判断出来了
- 整体构想：
    1. 判断首位数字大小，大、小直接返回结果，equal再继续判断下一位
    2. 判断第二位数字大小，大、小直接返回结果，equal再继续判断下一位，如果没有第二位数字则将指针跳回去，都没有就返回..
- 这个递归已经很明显了，直接开搞
- p.s. 最后也没有用指针，全程下标访问，之后再看优秀解法